(defstruct (state (:conc-name nil)
                  (:constructor make-state
                      (grid coms)))
  (grid nil :type (or null (simple-array int8 (* *))))
  (coms nil :type (or null (simple-array com (*))))
  (conns nil :type list))

(defstruct (com (:conc-name nil)
                (:constructor make-com
                    (com-row com-col)))
  (com-row 0 :type uint8)
  (com-col 0 :type uint8)
  (u-conn nil :type (or null com))
  (d-conn nil :type (or null com))
  (l-conn nil :type (or null com))
  (r-conn nil :type (or null com)))

;; (defun delete-crosses (row-conns col-conns)
;;   (nconc (delete-if (dlambda ((i j1 _ j2))
;;                       (some (dlambda ((k1 l k2 _))
;;                               (and (<= k1 i k2)
;;                                    (<= j1 l j2)))
;;                             col-conns))
;;                     row-conns)
;;          col-conns))

(defun random-conn (grid)
  (let ((conns (if (judge 0.5)
                   (row-conns grid (random *n*))
                   (col-conns grid (random *n*)))))
    (if conns
        (random-choice conns)
        (random-conn grid))))

(defvar *random-indices*)

(defun random-indices (&optional (length *n*))
  (let ((indices (setf *random-indices*
                  (nshuffle *random-indices*)))
        result)
    (dotimes (i length)
      (push (aref indices i) result))
    (sort result #'<)))

(defun random-connect (grid)
  (let ((conns (-> grid conns coerce-vector nshuffle coerce-list)))
    (filter-map (curry #'try-connect grid)
                conns)))

(defun random-row-reposition (grid row)
  (let ((js (row-coms grid row)))
    (if (null js)
        (values nil 0)
        (labels ((repos (j start end)
                   (let ((j* (random-a-b start end)))
                     (rotatef (aref grid row j)
                              (aref grid row j*))
                     j*)))
          (nlet rec ((js (nconc js (list *n*)))
                     (start 0)
                     (moves-list nil)
                     (count 0))
            (if (singletonp js)
                (values (apply #'nconc (nreverse moves-list))
                        count)
                (let ((j* (repos (first js) start (second js))))
                  (multiple-value-bind (ms c)
                      (make-row-moves row (car js) j*)
                    (rec (cdr js)
                         (1+ j*)
                         (cons ms moves-list)
                         (+ count c))))))))))

(defun random-col-reposition (grid col)
  (let ((is (col-coms grid col)))
    (if (null is)
        (values nil 0)
        (labels ((repos (i start end)
                   (let ((i* (random-a-b start end)))
                     (rotatef (aref grid i col)
                              (aref grid i* col))
                     i*)))
          (nlet rec ((is (nconc is (list *n*)))
                     (start 0)
                     (moves-list nil)
                     (count 0))
            (if (singletonp is)
                (values (apply #'nconc (nreverse moves-list))
                        count)
                (let ((i* (repos (first is) start (second is))))
                  (multiple-value-bind (ms c)
                      (make-col-moves col (car is) i*)
                    (rec (cdr is)
                         (1+ i*)
                         (cons ms moves-list)
                         (+ count c))))))))))

(defun random-reposition (grid)
  (if (judge 0.5)
      (random-row-reposition grid (random *n*))
      (random-col-reposition grid (random *n*))))

(defun random-repositions (grid)
  (nlet rec ((moves-list nil) (count 0))
    (if (>= count *random-repositions-moves-count*)
        (values (apply #'nconc (nreverse moves-list))
                count)
        (multiple-value-bind (ms c)
            (random-reposition grid)
          (rec (cons ms moves-list)
               (+ count c))))))

(defsubst row-coms (grid row)
  (filter (curry* #'comp grid row %)
          *indices*))

(defsubst col-coms (grid col)
  (filter (curry* #'comp grid % col)
          *indices*))
           
(defun random-row-reposition! (grid row)
  (let ((js (row-coms grid row)))
    (if (null js)
        (values nil 0)
        (destructuring-bind (l j r)
            (-> js
                (nconc (list -1)
                       %
                       (list *n*))
                (map-adjacents (lambda (&rest args)
                                 args)
                               % 3)
                random-choice)
          (let ((j* (random-a-b (1+ l) r)))
            (rotatef (aref grid row j)
                     (aref grid row j*))
            (make-row-moves row j j*))))))

(defun random-col-reposition! (grid col)
  (let ((is (col-coms grid col)))
    (if (null is)
        (values nil 0)
        (destructuring-bind (l i r)
            (-> is
                (nconc (list -1)
                       %
                       (list *n*))
                (map-adjacents (lambda (&rest args)
                                 args)
                               % 3)
                random-choice)
          (let ((i* (random-a-b (1+ l) r)))
            (rotatef (aref grid i col)
                     (aref grid i* col))
            (make-col-moves col i i*))))))
